# Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

import datetime
import json
import os
import random
import string
import time
import uuid
from urllib.parse import unquote, urlparse

import boto3
from boto3.dynamodb.conditions import Key
from chalice import Chalice, Rate
from jsonpath_ng import jsonpath, parse

app = Chalice(app_name='msam')

# update one region at this interval
NODE_UPDATE_RATE_MINUTES = 2

# update connections at this interval
CONNECTION_UPDATE_RATE_MINUTES = 2

# update subscribed alarm states at this interval
ALARM_UPDATE_RATE_MINUTES = 1


# table names generated by CloudFormation
ALARMS_TABLE_NAME = os.environ["ALARMS_TABLE_NAME"]
CHANNELS_TABLE_NAME = os.environ["CHANNELS_TABLE_NAME"]
CONTENT_TABLE_NAME = os.environ["CONTENT_TABLE_NAME"]
EVENTS_TABLE_NAME = os.environ["EVENTS_TABLE_NAME"]
LAYOUT_TABLE_NAME = os.environ["LAYOUT_TABLE_NAME"]
SETTINGS_TABLE_NAME = os.environ["SETTINGS_TABLE_NAME"]

# TTL provided via CloudFormation
CACHE_ITEM_TTL = int(os.environ["CACHE_ITEM_TTL"])

# DynamoDB
DYNAMO_CLIENT = boto3.client("dynamodb")
DYNAMO_RESOURCE = boto3.resource("dynamodb")


def put_setting(key, value):
    table = DYNAMO_RESOURCE.Table(SETTINGS_TABLE_NAME)
    # write to the database
    table.put_item(Item={
        "id": key,
        "value": value
    })


def get_setting(key):
    table = DYNAMO_RESOURCE.Table(SETTINGS_TABLE_NAME)
    # get the settings object
    try:
        response = table.get_item(
            Key={
                'id': key
            }
        )
        # return the response or an empty object
        if "Item" in response:
            settings = response["Item"]["value"]
        else:
            settings = None
    except Exception as e:
        print(e)
        settings = None
    return settings


def results_pager(list_function, list_locator, attr_transform):
    results = []
    next_token = None
    try:
        while True:
            if next_token is None or len(next_token) == 0:
                service_response = list_function()
            else:
                service_response = list_function(NextToken=next_token)
            results = results + list_locator(service_response)
            # check the paging token
            if "NextToken" in service_response:
                next_token = service_response["NextToken"]
            else:
                break
            if len(next_token) == 0:
                break
        for item in results:
            item = attr_transform(item)
    except Exception as e:
        print(e)
    return results

#
# body/response = [
#   { view, id, x, y },
#   { view, id, x, y },
#   { ... }
# ]


@app.route('/layout/view/{view}', cors=True,
           api_key_required=True, methods=['GET'])
def get_view_layout(view):
    settings = []
    table_name = LAYOUT_TABLE_NAME
    try:
        table = DYNAMO_RESOURCE.Table(table_name)
        request = app.current_request
        print(request.method)
        try:
            # get the settings object
            response = table.query(KeyConditionExpression=Key('view').eq(view))
            print(response)
            # return the response or an empty object
            if "Items" in response:
                settings = response["Items"]
            else:
                settings = []
            print("retrieved")
        except Exception as e:
            print("not found")
            settings = []
    except Exception as e:
        # send the exception back in the object
        print(e)
        settings = {
            "exception": str(e)
        }
    return settings


@app.route('/layout/nodes', cors=True, api_key_required=True,
           methods=['PUT', 'POST'],
           content_types=['application/json',
                          'application/x-www-form-urlencoded'])
def set_node_layout():
    settings = {}
    table_name = LAYOUT_TABLE_NAME
    try:
        table = DYNAMO_RESOURCE.Table(table_name)
        print(app.current_request.json_body)
        layout_items = app.current_request.json_body
        # write to the database in batch
        for item in layout_items:
            table.put_item(Item=item)
        settings = {"message": "saved"}
        print(settings)
    except Exception as e:
        # send the exception back in the object
        print(e)
        settings = {
            "exception": str(e)
        }
    return settings


@app.route('/layout/node/{id}', cors=True, api_key_required=True,
           methods=['DELETE'],
           content_types=['application/json',
                          'application/x-www-form-urlencoded'])
def delete_node_layout(id):
    print("deleting layout for " + id)
    settings = {}
    table_name = LAYOUT_TABLE_NAME
    try:
        table = DYNAMO_RESOURCE.Table(table_name)
        try:
            # get each layout record for the ID
            response = table.query(
                IndexName="IdIndex",
                KeyConditionExpression=Key('id').eq(id))
            print(response)
            # remove each record
            if "Items" in response:
                for item in response["Items"]:
                    table.delete_item(Key={"view": item["view"], "id": id})
        except Exception as e:
            print("not found")
            settings = {"message": "not found"}
        settings = {"message": "deleted"}
        print(settings)
    except Exception as e:
        # send the exception back in the object
        print(e)
        settings = {
            "exception": str(e)
        }
    return settings


@app.route('/channels', cors=True, api_key_required=True, methods=['GET'])
def get_channel_list():
    channels = get_setting("channels")
    if not channels:
        channels = []
    return channels


# data = [ nodeid1, nodeid2, nodeid3 ]

@app.route('/channel/{name}',
           cors=True,
           api_key_required=True,
           methods=['PUT', 'POST'],
           content_types=['application/json',
                          'application/x-www-form-urlencoded'])
def set_channel_nodes(name):
    try:
        name = unquote(name)
        table = DYNAMO_RESOURCE.Table(CHANNELS_TABLE_NAME)
        print(app.current_request.json_body)
        node_ids = app.current_request.json_body
        # write the channel nodes to the database
        for id in node_ids:
            item = {
                "channel": name,
                "id": id
            }
            table.put_item(Item=item)
        # update the list of channels in settings
        name_list = get_setting("channels")
        if not name_list:
            name_list = []
        if name not in name_list:
            name_list.append(name)
            put_setting("channels", name_list)
        result = {"message": "saved"}
        print(result)
    except Exception as e:
        # send the exception back in the object
        print(e)
        result = {
            "exception": str(e)
        }
    return result


@app.route('/channel/{name}',
           cors=True,
           api_key_required=True,
           methods=['GET'])
def get_channel_nodes(name):
    try:
        name = unquote(name)
        table_name = CHANNELS_TABLE_NAME
        table = DYNAMO_RESOURCE.Table(table_name)
        request = app.current_request
        print(request.method)
        try:
            # get the settings object
            response = table.query(
                KeyConditionExpression=Key('channel').eq(name))
            print(response)
            # return the response or an empty object
            if "Items" in response:
                settings = response["Items"]
            else:
                settings = []
            print("retrieved")
        except Exception as e:
            print("not found")
            settings = []
    except Exception as e:
        # send the exception back in the object
        print(e)
        settings = {
            "exception": str(e)
        }
    return settings


@app.route('/channel/{name}',
           cors=True,
           api_key_required=True,
           methods=['DELETE'])
def delete_channel_nodes(name):
    try:
        name = unquote(name)
        table_name = CHANNELS_TABLE_NAME
        table = DYNAMO_RESOURCE.Table(table_name)
        request = app.current_request
        print(request.method)
        try:
            # get the settings object
            response = table.query(
                KeyConditionExpression=Key('channel').eq(name))
            print(response)
            # return the response or an empty object
            if "Items" in response:
                for item in response["Items"]:
                    table.delete_item(Key={
                        "channel": item["channel"],
                        "id": item["id"]
                    })
            name_list = get_setting("channels")
            if not name_list:
                name_list = []
            if name in name_list:
                name_list.remove(name)
                put_setting("channels", name_list)
            print("channel items deleted, channel list updated")
        except Exception as e:
            print("not found")
        response = {"message": "done"}
    except Exception as e:
        # send the exception back in the object
        print(e)
        response = {
            "exception": str(e)
        }
    return response


@app.route('/settings/{item_key}',
           cors=True,
           api_key_required=True,
           methods=['GET', 'PUT', 'POST', "DELETE"],
           content_types=['application/json',
                          'application/x-www-form-urlencoded'])
def application_settings(item_key):
    try:
        item_key = unquote(item_key)
        print(item_key)
        settings = {}
        request = app.current_request
        print(request.method)
        if request.method == 'PUT' or request.method == 'POST':
            print(app.current_request.json_body)
            settings = app.current_request.json_body
            put_setting(item_key, settings)
            settings = {"message": "saved"}
            print(settings)
        elif request.method == 'GET':
            settings = get_setting(item_key)
        elif request.method == 'DELETE':
            table = DYNAMO_RESOURCE.Table(SETTINGS_TABLE_NAME)
            table.delete_item(Key={"id": item_key})
    except Exception as e:
        # send the exception back in the object
        print(e)
        settings = {
            "exception": str(e)
        }
    return settings


def mediapackage_channels(region):
    service = boto3.client("mediapackage", region_name=region)
    jsonpath_expr = parse('$..Password')
    response = service.list_channels()
    items = response['Channels']
    while "NextToken" in response:
        response = service.list_channels(NextToken=response["NextToken"])
        items = items + response['Channels']
    jsonpath_expr.update(items, "XXXXXXXXXXXX")
    return items


def mediapackage_origin_endpoints(region):
    service = boto3.client("mediapackage", region_name=region)
    response = service.list_origin_endpoints()
    items = response['OriginEndpoints']
    while "NextToken" in response:
        response = service.list_origin_endpoints(
            NextToken=response["NextToken"])
        items = items + response['OriginEndpoints']
    return items


def medialive_channels(region):
    service = boto3.client("medialive", region_name=region)
    response = service.list_channels()
    items = response['Channels']
    while "NextToken" in response:
        response = service.list_channels(NextToken=response["NextToken"])
        items = items + response['Channels']
    return items


def medialive_inputs(region):
    service = boto3.client("medialive", region_name=region)
    response = service.list_inputs()
    items = response['Inputs']
    while "NextToken" in response:
        response = service.list_inputs(NextToken=response["NextToken"])
        items = items + response['Inputs']
    return items


def mediastore_containers(region):
    service = boto3.client("mediastore", region_name=region)
    response = service.list_containers()
    items = response['Containers']
    while "NextToken" in response:
        response = service.list_containers(NextToken=response["NextToken"])
        items = items + response['Containers']
    for item in items:
        item['CreationTime'] = str(item['CreationTime'])
    return items


@app.route('/cached/{service}/{region}',
           cors=True,
           api_key_required=True,
           methods=['GET'])
def cached_by_service_region(service, region):
    try:
        service = unquote(service)
        region = unquote(region)
        ddb_table_name = CONTENT_TABLE_NAME
        ddb_index_name = "ServiceRegionIndex"
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        response = ddb_table.query(
            IndexName=ddb_index_name,
            KeyConditionExpression=Key('service').eq(
                service) & Key('region').eq(region)
        )
        items = response["Items"]
        while "LastEvaluatedKey" in response:
            response = ddb_table.query(
                IndexName=ddb_index_name,
                KeyConditionExpression=Key('service').eq(
                    service) & Key('region').eq(region),
                ExclusiveStartKey=response['LastEvaluatedKey']
            )
            items = items + response["Items"]
        return items
    except Exception as e:
        print(e)
        return {
            "message": str(e)
        }


def cached_by_service(service):
    try:
        ddb_table_name = CONTENT_TABLE_NAME
        # ddb_index_name = "service-index"
        ddb_index_name = "ServiceRegionIndex"
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        response = ddb_table.query(
            IndexName=ddb_index_name,
            KeyConditionExpression=Key('service').eq(service)
        )
        items = response["Items"]
        while "LastEvaluatedKey" in response:
            response = ddb_table.query(
                IndexName=ddb_index_name,
                KeyConditionExpression=Key('service').eq(service),
                ExclusiveStartKey=response['LastEvaluatedKey']
            )
            items = items + response["Items"]
        return items
    except Exception as e:
        print(e)
        return {
            "message": str(e)
        }


#
# required cache entry format -- exactly the same as cache output format
# all attributes are required
# data is a string, encode json or xml to string
#

@app.route('/cached',
           cors=True,
           api_key_required=True,
           methods=['PUT', 'POST'],
           content_types=['application/json',
                          'application/x-www-form-urlencoded'])
def put_cached_data():
    try:
        ddb_table_name = CONTENT_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        cache_entries = app.current_request.json_body
        print(cache_entries)
        # write the channel nodes to the database
        for entry in cache_entries:
            # workaround for dynamodb numeric types
            entry["expires"] = int(entry["expires"])
            entry["updated"] = int(entry["updated"])
            ddb_table.put_item(Item=entry)
        return {
            "message": "saved"
        }
    except Exception as e:
        print(e)
        return {
            "message": str(e)
        }


def cloudfront_distributions():
    service = boto3.client("cloudfront")
    response = service.list_distributions()
    items = response["DistributionList"]["Items"]
    while "NextMarker" in response["DistributionList"]:
        response = service.list_distributions(
            Marker=response["DistributionList"]["NextMarker"])
        items = items + response["DistributionList"]["Items"]
    for item in items:
        item['LastModifiedTime'] = str(item['LastModifiedTime'])
    return items


def s3_buckets():
    service = boto3.client("s3")
    buckets = service.list_buckets()
    for item in buckets["Buckets"]:
        item["CreationDate"] = str(item["CreationDate"])
    return buckets["Buckets"]


@app.route('/regions', cors=True, api_key_required=True, methods=['GET'])
def regions():
    service = boto3.client("ec2")
    response = service.describe_regions()
    return response["Regions"]


#
# CloudWatch Alarms
#


def filtered_alarm(alarm):
    filtered = {
        "AlarmArn": alarm["AlarmArn"],
        "AlarmName": alarm["AlarmName"],
        "MetricName": alarm["MetricName"],
        "Namespace": alarm["Namespace"],
        "StateValue": alarm["StateValue"],
        "StateUpdated": int(alarm["StateUpdatedTimestamp"].timestamp())
    }
    return filtered


@app.route('/cloudwatch/alarms/all/{region}',
           cors=True,
           api_key_required=True,
           methods=['GET'])
def get_cloudwatch_alarms_region(region):
    alarms = []
    try:
        region = unquote(region)
        client = boto3.client('cloudwatch', region_name=region)
        response = client.describe_alarms()
        # return the response or an empty object
        if "MetricAlarms" in response:
            for alarm in response["MetricAlarms"]:
                alarms.append(filtered_alarm(alarm))
        while "NextToken" in response:
            response = client.describe_alarms(NextToken=response["NextToken"])
            # return the response or an empty object
            if "MetricAlarms" in response:
                for alarm in response["MetricAlarms"]:
                    alarms.append(filtered_alarm(alarm))
    except Exception as e:
        print(e)
    return alarms


@app.lambda_function()
def incoming_cloudwatch_alarm(event, context):
    print(event)
    try:
        updated = int(time.time())
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        for record in event["Records"]:
            region = record["EventSubscriptionArn"].split(":")[3]
            alarm = json.loads(record["Sns"]["Message"])
            name = alarm["AlarmName"]
            region_alarm_name = "{}:{}".format(region, name)
            # look up the resources with this region alarm name
            subscribers = subscribers_to_alarm(name, region)
            for resource_arn in subscribers:
                item = {
                    "RegionAlarmName": region_alarm_name,
                    "ResourceArn": resource_arn,
                    "StateValue": alarm["NewStateValue"],
                    "Namespace": alarm["Trigger"]["Namespace"],
                    "StateUpdated": int(
                        datetime.datetime.strptime(
                            alarm["StateChangeTime"],
                            '%Y-%m-%dT%H:%M:%S.%f%z').timestamp()),
                    "Updated": updated}
                ddb_table.put_item(Item=item)
                print("{} updated via alarm notification".format(resource_arn))
    except Exception as e:
        print(e)
    return True


#
# request body (json)
#
# [ "arn", "arn", "arn", ... ]
#


@app.route('/cloudwatch/alarm/{alarm_name}/region/{region}/subscribe',
           cors=True,
           api_key_required=True,
           methods=['PUT', 'POST'])
def subscribe_resource_to_alarm(alarm_name, region):
    try:
        alarm_name = unquote(alarm_name)
        region = unquote(region)
        region_alarm_name = "{}:{}".format(region, alarm_name)
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        resources = app.current_request.json_body
        for resource_arn in resources:
            print(resource_arn)
            # store it
            item = {
                "RegionAlarmName": region_alarm_name,
                "ResourceArn": resource_arn
            }
            ddb_table.put_item(Item=item)
        return True
    except Exception as e:
        print(e)
        return False


@app.route('/cloudwatch/alarm/{alarm_name}/region/{region}/unsubscribe',
           cors=True,
           api_key_required=True,
           methods=['PUT', 'POST'])
def unsubscribe_resource_to_alarm(alarm_name, region):
    try:
        alarm_name = unquote(alarm_name)
        region = unquote(region)
        region_alarm_name = "{}:{}".format(region, alarm_name)
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        resources = app.current_request.json_body
        for resource_arn in resources:
            # store it
            item = {
                "RegionAlarmName": region_alarm_name,
                "ResourceArn": resource_arn
            }
            # delete it
            ddb_table.delete_item(Key=item)
        return True
    except Exception as e:
        print(e)
        return False


@app.route('/cloudwatch/alarm/{alarm_name}/region/{region}/subscribers',
           cors=True,
           api_key_required=True,
           methods=['GET'])
def subscribers_to_alarm(alarm_name, region):
    subscribers = set()
    try:
        alarm_name = unquote(alarm_name)
        region = unquote(region)
        region_alarm_name = "{}:{}".format(region, alarm_name)
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        ddb_index_name = 'RegionAlarmNameIndex'
        response = ddb_table.query(
            IndexName=ddb_index_name,
            KeyConditionExpression=Key('RegionAlarmName').eq(region_alarm_name)
        )
        for item in response["Items"]:
            subscribers.add(item["ResourceArn"])
        while "LastEvaluatedKey" in response:
            response = ddb_table.query(
                IndexName=ddb_index_name,
                KeyConditionExpression=Key(
                    'RegionAlarmName').eq(region_alarm_name),
                ExclusiveStartKey=response['LastEvaluatedKey']
            )
            for item in response["Items"]:
                subscribers.add(item["ResourceArn"])
    except Exception as e:
        print(e)
    return sorted(subscribers)


#
# return resource ARNs with any subscribed alarms in specified state
#

@app.route('/cloudwatch/alarms/{alarm_state}/subscribers',
           cors=True,
           api_key_required=True,
           methods=['GET'])
def subscribed_with_state(alarm_state):
    resources = {}
    try:
        alarm_state = unquote(alarm_state)
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        response = ddb_table.query(
            IndexName='StateValueIndex',
            KeyConditionExpression=Key('StateValue').eq(alarm_state))
        for item in response["Items"]:
            # store it
            if item["ResourceArn"] in resources:
                entry = resources[item["ResourceArn"]]
                entry["AlarmCount"] = entry["AlarmCount"] + 1
            else:
                entry = {
                    "ResourceArn": item["ResourceArn"],
                    "AlarmCount": 1
                }
            resources[item["ResourceArn"]] = entry
        while "LastEvaluatedKey" in response:
            response = ddb_table.query(
                IndexName='StateValueIndex',
                KeyConditionExpression=Key('StateValue').eq(alarm_state),
                ExclusiveStartKey=response['LastEvaluatedKey'])
            for item in response["Items"]:
                # store it
                if item["ResourceArn"] in resources:
                    entry = resources[item["ResourceArn"]]
                    entry["AlarmCount"] = entry["AlarmCount"] + 1
                else:
                    entry = {
                        "ResourceArn": item["ResourceArn"],
                        "AlarmCount": 1
                    }
                resources[item["ResourceArn"]] = entry
    except Exception as e:
        print(e)
    return list(resources.values())


#
# return subscribed alarm data for specified resource
#

@app.route('/cloudwatch/alarms/subscriber/{resource_arn}',
           cors=True,
           api_key_required=True,
           methods=['GET'])
def alarms_for_subscriber(resource_arn):
    alarms = {}
    try:
        resource_arn = unquote(resource_arn)
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        ddb_index_name = 'ResourceArnIndex'
        response = ddb_table.query(
            IndexName=ddb_index_name,
            KeyConditionExpression=Key('ResourceArn').eq(resource_arn)
        )
        for item in response["Items"]:
            ran = item["RegionAlarmName"]
            split_attr = ran.split(':', maxsplit=1)
            region = split_attr[0]
            name = split_attr[1]
            item["Region"] = region
            item["AlarmName"] = name
            item.pop("ResourceArn", None)
            item.pop("RegionAlarmName", None)
            item.pop("Updated", None)
            # alarm = {
            #     "Region": region,
            #     "AlarmName": name,
            # }
            alarms[ran] = item
        while "LastEvaluatedKey" in response:
            response = ddb_table.query(
                IndexName=ddb_index_name,
                KeyConditionExpression=Key('ResourceArn').eq(resource_arn),
                ExclusiveStartKey=response['LastEvaluatedKey']
            )
            for item in response["Items"]:
                ran = item["RegionAlarmName"]
                split_attr = ran.split(':', maxsplit=1)
                region = split_attr[0]
                name = split_attr[1]
                item["Region"] = region
                item["AlarmName"] = name
                item.pop("ResourceArn", None)
                item.pop("RegionAlarmName", None)
                item.pop("Updated", None)
                # alarm = {
                #     "Region": region,
                #     "AlarmName": name,
                # }
                alarms[ran] = item
    except Exception as e:
        print(e)
    results = []
    for key in sorted(alarms):
        results.append(alarms[key])
    return results


#
# Return a unique list of all subscribed alarms
#

@app.route('/cloudwatch/alarms/subscribed',
           cors=True,
           api_key_required=True,
           methods=['GET'])
def all_subscribed_alarms():
    alarms = {}
    try:
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        response = ddb_table.scan()
        for item in response["Items"]:
            split_attr = item["RegionAlarmName"].split(':', maxsplit=1)
            region = split_attr[0]
            name = split_attr[1]
            alarm = {
                "Region": region,
                "AlarmName": name
            }
            alarms[item["RegionAlarmName"]] = alarm
        while "LastEvaluatedKey" in response:
            response = ddb_table.scan(
                ExclusiveStartKey=response['LastEvaluatedKey']
            )
            for item in response["Items"]:
                split_attr = item["RegionAlarmName"].split(':', maxsplit=1)
                region = split_attr[0]
                name = split_attr[1]
                alarm = {
                    "Region": region,
                    "AlarmName": name
                }
                alarms[item["RegionAlarmName"]] = alarm
    except Exception as e:
        print(e)
    results = []
    for key in sorted(alarms):
        results.append(alarms[key])
    return results


#    _____   _____ _  _ _____ ___
#   | __\ \ / / __| \| |_   _/ __|
#   | _| \ V /| _|| .` | | | \__ \
#   |___| \_/ |___|_|\_| |_| |___/
#

# data = {
#     "arn": "...",
#     "state": "..."
# }

@app.route('/cloudwatch/events/arn',
           cors=True,
           api_key_required=True,
           methods=['POST', 'PUT'])
def get_cloudwatch_events_arn_state():
    print(app.current_request.json_body)
    data = app.current_request.json_body
    arn = data["arn"]
    state = data["state"]
    print(arn)
    print(state)
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(EVENTS_TABLE_NAME)
    response = table.query(
        IndexName='ResourceAlarmStateIndex',
        KeyConditionExpression=Key('resource_arn').eq(arn) &
        Key('alarm_state').eq(state))
    if "Items" in response:
        alarms = response["Items"]
    else:
        alarms = []
    return alarms


@app.route('/cloudwatch/events/state/{state}',
           cors=True,
           api_key_required=True,
           methods=['GET'])
def get_cloudwatch_events_state(state):
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(EVENTS_TABLE_NAME)
    response = table.query(
        IndexName='AlarmStateIndex',
        KeyConditionExpression=Key('alarm_state').eq(state))
    if "Items" in response:
        alarms = response["Items"]
    else:
        alarms = []
    return alarms


@app.route('/ping', cors=True, api_key_required=True, methods=['GET'])
def ping():
    return {
        "message": "pong",
        "buildstamp": os.environ["BUILD_STAMP"]
    }


def node_to_ddb_item(arn, service, region, config):
    now = int(time.time())
    item = {
        "arn": arn,
        "region": region,
        "service": service,
        "updated": now,
        "expires": now + CACHE_ITEM_TTL,
        "data": json.dumps(config, default=str)
    }
    return item


def connection_to_ddb_item(from_arn, to_arn, service, config):
    now = int(time.time())
    item = {
        "arn": "{}:{}".format(from_arn, to_arn),
        "from": from_arn,
        "to": to_arn,
        "region": "global",
        "service": service,
        "updated": now,
        "expires": now + CACHE_ITEM_TTL,
        "data": json.dumps(config, default=str)
    }
    return item


def put_ddb_items(items):
    ddb_table_name = CONTENT_TABLE_NAME
    # shared resource and table
    ddb_resource = boto3.resource('dynamodb')
    ddb_table = ddb_resource.Table(ddb_table_name)
    for item in items:
        ddb_table.put_item(Item=item)
    return True


# node mappers

def medialive_input_ddb_items(region):
    items = []
    for input in medialive_inputs(region):
        arn = input["Arn"]
        service = "medialive-input"
        items.append(node_to_ddb_item(arn, service, region, input))
    return items


def medialive_channel_ddb_items(region):
    items = []
    for channel in medialive_channels(region):
        arn = channel["Arn"]
        service = "medialive-channel"
        items.append(node_to_ddb_item(arn, service, region, channel))
    return items


def mediapackage_channel_ddb_items(region):
    items = []
    for channel in mediapackage_channels(region):
        arn = channel["Arn"]
        service = "mediapackage-channel"
        items.append(node_to_ddb_item(arn, service, region, channel))
    return items


def mediapackage_origin_endpoint_ddb_items(region):
    items = []
    for endpoint in mediapackage_origin_endpoints(region):
        arn = endpoint["Arn"]
        service = "mediapackage-origin-endpoint"
        items.append(node_to_ddb_item(arn, service, region, endpoint))
    return items


def mediastore_container_ddb_items(region):
    items = []
    for container in mediastore_containers(region):
        arn = container["ARN"]
        service = "mediastore-container"
        items.append(node_to_ddb_item(arn, service, region, container))
    return items


def s3_bucket_ddb_items():
    items = []
    for bucket in s3_buckets():
        arn = "arn:aws:s3:::{}".format(bucket["Name"])
        service = "s3"
        items.append(node_to_ddb_item(arn, service, "global", bucket))
    return items


def cloudfront_distribution_ddb_items():
    items = []
    for item in cloudfront_distributions():
        arn = item["ARN"]
        service = "cloudfront-distribution"
        items.append(node_to_ddb_item(arn, service, "global", item))
    return items


#
# Connection Mappers
#


def medialive_channel_mediapackage_channel_ddb_items():
    items = []
    try:
        # get medialive channels
        medialive_channels = cached_by_service("medialive-channel")
        # get mediapackage channels
        mediapackage_channels = cached_by_service("mediapackage-channel")
        # compare each medialive output url to a mediapackage ingest url
        for ml_channel in medialive_channels:
            ml_channel_data = json.loads(ml_channel["data"])
            for destination in ml_channel_data["Destinations"]:
                for setting in destination["Settings"]:
                    ml_url = setting["Url"]
                    # convert a mediapackage v1 ingest url to a v2 url before
                    # checking
                    try:
                        parsed = urlparse(ml_url)
                        if parsed.path.startswith("/in/v1/"):
                            pieces = parsed.path.split("/")
                            if len(pieces) == 5:
                                ml_url = "{scheme}://{netloc}/in/v2/{uid}/{uid}/channel".format(
                                    scheme=parsed.scheme, netloc=parsed.netloc, uid=pieces[3])
                    except Exception as e:
                        print(e)
                    for mp_channel in mediapackage_channels:
                        mp_channel_data = json.loads(mp_channel["data"])
                        for ingest_endpoint in mp_channel_data["HlsIngest"]["IngestEndpoints"]:
                            mp_url = ingest_endpoint["Url"]
                            if ml_url == mp_url:
                                # create a 'connection' out of matches
                                config = {
                                    "from": ml_channel_data["Arn"],
                                    "to": mp_channel_data["Arn"],
                                    "pipeline": destination["Settings"].index(setting)}
                                print(config)
                                items.append(connection_to_ddb_item(
                                    ml_channel_data["Arn"],
                                    mp_channel_data["Arn"],
                                    "medialive-channel-mediapackage-channel",
                                    config))
    except Exception as e:
        print(e)
    return items


def medialive_channel_mediastore_container_ddb_items():
    items = []
    try:
        # get medialive channels
        medialive_channels = cached_by_service("medialive-channel")
        # get mediastore containers
        mediastore_containers = cached_by_service("mediastore-container")
        # compare each medialive output url to a mediastore container endpoint
        # url
        for ml_channel in medialive_channels:
            ml_channel_data = json.loads(ml_channel["data"])
            for destination in ml_channel_data["Destinations"]:
                for setting in destination["Settings"]:
                    ml_url = setting["Url"]
                    parsed_destination = urlparse(ml_url)
                    if "mediastore" in parsed_destination.netloc:
                        for ms_container in mediastore_containers:
                            container_data = json.loads(ms_container["data"])
                            parsed_endpoint = urlparse(
                                container_data["Endpoint"])
                            if parsed_destination.netloc == parsed_endpoint.netloc:
                                # create a 'connection' out of matches
                                config = {
                                    "from": ml_channel_data["Arn"],
                                    "to": container_data["ARN"],
                                    "scheme": parsed_destination.scheme
                                }
                                print(config)
                                items.append(connection_to_ddb_item(
                                    ml_channel_data["Arn"],
                                    container_data["ARN"],
                                    "medialive-channel-mediastore-container",
                                    config))
    except Exception as e:
        print(e)
    return items


def mediastore_container_medialive_input_ddb_items():
    items = []
    try:
        # get medialive inputs
        medialive_inputs = cached_by_service("medialive-input")
        # get mediastore containers
        mediastore_containers = cached_by_service("mediastore-container")
        # check the inputs that pull from mediastore containers
        for ml_input in medialive_inputs:
            ml_input_data = json.loads(ml_input["data"])
            for source in ml_input_data["Sources"]:
                ml_url = source["Url"]
                parsed_source = urlparse(ml_url)
                if "mediastore" in parsed_source.netloc:
                    for ms_container in mediastore_containers:
                        container_data = json.loads(ms_container["data"])
                        parsed_endpoint = urlparse(
                            container_data["Endpoint"])
                        if parsed_source.netloc == parsed_endpoint.netloc:
                            # create a 'connection' out of matches
                            config = {
                                "from": container_data["ARN"],
                                "to": ml_input_data["Arn"],
                                "scheme": parsed_source.scheme
                            }
                            print(config)
                            items.append(
                                connection_to_ddb_item(
                                    container_data["ARN"],
                                    ml_input_data["Arn"],
                                    "mediastore-container-medialive-input",
                                    config))
    except Exception as e:
        print(e)
    return items


def update_regional_ddb_items(region_name):
    try:
        put_ddb_items(medialive_input_ddb_items(region_name))
    except Exception as e:
        print(e)
    try:
        put_ddb_items(medialive_channel_ddb_items(region_name))
    except Exception as e:
        print(e)
    try:
        put_ddb_items(mediapackage_channel_ddb_items(region_name))
    except Exception as e:
        print(e)
    try:
        put_ddb_items(mediapackage_origin_endpoint_ddb_items(region_name))
    except Exception as e:
        print(e)
    try:
        put_ddb_items(mediastore_container_ddb_items(region_name))
    except Exception as e:
        print(e)


def update_connection_ddb_items():
    try:
        put_ddb_items(medialive_channel_mediapackage_channel_ddb_items())
        put_ddb_items(medialive_channel_mediastore_container_ddb_items())
        put_ddb_items(mediastore_container_medialive_input_ddb_items())
    except Exception as e:
        print(e)


@app.schedule(Rate(NODE_UPDATE_RATE_MINUTES, unit=Rate.MINUTES))
def update_nodes(event):
    try:
        never_regions_key = "never-cache-regions"
        never_regions = get_setting(never_regions_key)
        if never_regions is None:
            never_regions = []
        settings_key = "cache-next-region"
        # make a region name list
        region_name_list = []
        for region in regions():
            rn = region["RegionName"]
            # exclude regions listed in never-cache setting
            if rn not in never_regions:
                region_name_list.append(rn)
            else:
                print("{} in {} setting".format(rn, never_regions_key))
        # sort it
        region_name_list.sort()
        # get the next region to process
        next_region = get_setting(settings_key)
        # start at the beginning if no previous setting
        if next_region is None:
            next_region = region_name_list[0]
        # otherwise it's saved for us
        region_name = next_region
        # store the region for the next schedule
        try:
            # process global after the end of the region list
            if region_name_list.index(next_region) + \
                    1 >= len(region_name_list):
                next_region = "global"
            else:
                next_region = region_name_list[region_name_list.index(
                    next_region) + 1]
        except Exception as e:
            # start over if we don't recognize the region, ex. global
            next_region = region_name_list[0]
        # store it
        put_setting(settings_key, next_region)
        # update the region
        print("updating region {}".format(region_name))
        if region_name == "global":
            put_ddb_items(s3_bucket_ddb_items())
            put_ddb_items(cloudfront_distribution_ddb_items())
        else:
            update_regional_ddb_items(region_name)
    except Exception as e:
        print(e)
    return True


@app.schedule(Rate(CONNECTION_UPDATE_RATE_MINUTES, unit=Rate.MINUTES))
def update_connections(event):
    try:
        update_connection_ddb_items()
    except Exception as e:
        print(e)
    return True


@app.schedule(Rate(ALARM_UPDATE_RATE_MINUTES, unit=Rate.MINUTES))
def update_alarms(event):
    try:
        print("update alarms")
        resource_cache = {}
        updated = int(time.time())
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        for alarm in all_subscribed_alarms():
            region = alarm["Region"]
            name = alarm["AlarmName"]
            if region in resource_cache:
                cloudwatch = resource_cache[region]
            else:
                cloudwatch = boto3.resource('cloudwatch', region_name=region)
                resource_cache[region] = cloudwatch
            alarm = cloudwatch.Alarm(name)
            region_alarm_name = "{}:{}".format(region, name)
            # look up the resources with this region alarm name
            subscribers = subscribers_to_alarm(name, region)
            for resource_arn in subscribers:
                item = {
                    "RegionAlarmName": region_alarm_name,
                    "ResourceArn": resource_arn,
                    "StateValue": alarm.state_value,
                    "Namespace": alarm.namespace,
                    "StateUpdated":
                        int(alarm.state_updated_timestamp.timestamp()),
                    "Updated": updated
                }
                ddb_table.put_item(Item=item)
    except Exception as e:
        print(e)
    return True
